# Домашнее задание к занятию «Работа в терминале. Лекция 2»

### Цель задания

В результате выполнения задания вы:

* познакомитесь с возможностями некоторых команд (grep, wc), чтобы в дальнейшем обращать внимание на схожие особенности команд;
* попрактикуетесь с перенаправлением потоков ввода, вывода, ошибок, что поможет грамотно использовать функционал в скриптах;
* поработаете с файловой системой /proc как примером размещения информации о процессах.


### Инструкция к заданию

1. Создайте .md-файл для ответов на вопросы задания в своём репозитории, после выполнения прикрепите ссылку на него в личном кабинете.
2. Любые вопросы по решению задач задавайте в чате учебной группы.

------
------

## Задание

Ответьты на вопросы:

##	1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей и поясните, если считаете, что она могла бы быть другого типа.

Это внутренняя команда, возвращающая код завершения и меняющая текущую рабочую директорию для оболочки, которая её выполнила. В использование её как внешней не имеет смысла т.к. команда cd должна применить изменение к текущему запущенному процессу оболочки. Если запустить её как внешнюю, то она изменит каталог для запущенного процесса, но при его завершении, изменения каталога не сохранятся.

Как в Linux посмотреть чем именно является команда или файл?

Команадами file или type.

##	2. Какая альтернатива без pipe для команды `grep <some_string> <some_file> | wc -l`?  

Альтернативой без использования конвейера (pipe) для команды grep <some_string> <some_file> | wc -l может быть использование опции -c команды grep, которая позволяет считать количество строк, содержащих искомую подстроку в указанном файле: grep -c <some_string> <some_file>

Эта команда выведет только количество строк, содержащих искомую подстроку, без лишней информации, которую выдаёт команда wc.

##	3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

В моей виртуальной машине Ubuntu 20.04 процесс с PID 1 является systemd. узнал это написав команду "ps -p 1 -o comm="

##	4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?

Перенаправление вывода stderr на другую сессию терминала можно выполнить с помощью команды tty. Например, для перенаправления stderr команды ls на терминал, связанный с псевдо-терминалом /dev/pts/2, можно использовать следующую команду: ls /path/to/dir 2> /dev/pts/2

Здесь 2> означает перенаправление stderr, а /dev/pts/2 - путь к псевдо-терминалу, на который будет перенаправлен вывод ошибок.

##	5. Получится ли одновременно передать команде файл на stdin и вывести её stdout в другой файл? Приведите работающий пример.

vagrant@vagrant:~$ echo "Hello, world!" > 1.txt

vagrant@vagrant:~$ cat <1.txt >2.txt

vagrant@vagrant:~$ cat 2.txt

Hello, world!

vagrant@vagrant:~$

##	6. Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Да, это возможно. Для этого можно использовать утилиту ttyecho, которая позволяет отправлять текстовые данные в другую TTY.

Допустим, у нас есть две виртуальные консоли TTY1 и TTY2, и мы хотим отправить данные из TTY1 в TTY2. Сначала необходимо переключиться на TTY2 (обычно это можно сделать сочетанием клавиш Ctrl + Alt + F2). Затем необходимо запустить в TTY2 утилиту tty, чтобы узнать имя TTY: 

$ tty 

/dev/tty2

В данном примере имя TTY2 - /dev/tty2. Теперь можно переключиться обратно на TTY1 и запустить команду, которая будет выводить данные: $ echo "Hello, TTY2!" > /dev/tty2

Теперь в TTY2 должно появиться сообщение "Hello, TTY2!".

Ответ на вторую часть вопроса зависит от эмулятора TTY, который используется. Например, в большинстве эмуляторов TTY для X Window System (например, gnome-terminal, konsole, xterm) можно открыть новую вкладку и запустить команду tty для того, чтобы узнать имя TTY, и затем использовать tail -f /dev/<имя_TTY> для просмотра выводимых данных.

##	7. Выполните команду `bash 5>&1`. К чему она приведёт?

Команда bash 5>&1 создаст новый процесс оболочки bash, который будет использовать дескриптор файлов 5 для перенаправления вывода в стандартный поток вывода (дескриптор 1).

 Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?

Команда echo netology > /proc/$$/fd/5 запишет строку "netology" в файловый дескриптор 5 процесса, запустившего данную команду. 

Ранее была выполнена команда bash 5>&1, то дескриптор 5 будет указывать на стандартный вывод (stdout) процесса bash. Таким образом, команда echo netology > /proc/$$/fd/5 выведала строку "netology" на экран терминала, так как stdout процесса bash направлен на терминал.

##	8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв отображение stdout на pty?  
	
Да, в качестве входного потока для pipe можно использовать только stderr команды, не потеряв отображение stdout на pty. Для этого нужно перенаправить stdout на stderr внутри команды перед использованием pipe.

Например, команда command 2>&1 | other_command перенаправляет stderr команды command на stdout и передает их на вход команде other_command, при этом stdout команды command сохраняется и отображается на терминале.

Здесь 2>&1 - это перенаправление stderr на stdout. Символ > означает перенаправление, а & указывает, что мы перенаправляем дескриптор файлов, а не сам файл.

Таким образом, используя такое перенаправление, мы можем передавать только stderr команды на вход pipe, сохраняя при этом отображение stdout на терминале.

##	9. Что выведет команда `cat /proc/$$/environ`? Как ещё можно получить аналогичный по содержанию вывод?

В моём случае выдало это:

SHELL=/bin/bashPWD=/home/vagrantLOGNAME=vagrantXDG_SESSION_TYPE=ttyMOTD_SHOWN=pamHOME=/home/vagrantLANG=en_US.UTF-8LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:SSH_CONNECTION=10.0.2.2 57365 10.0.2.15 22LESSCLOSE=/usr/bin/lesspipe %s %sXDG_SESSION_CLASS=userTERM=xterm-256colorLESSOP

Аналогичный вывод можно получить с помощью команды env -0.

Она выведет список переменных окружения для текущего процесса,

разделенных нулевыми байтами, что делает их удобными для 
 
обработки в скриптах. Если нужно вывести значения переменных 
 
окружения в более читабельном формате, можно использовать 
 
команду printenv. 

##	10. Используя `man`, опишите, что доступно по адресам `/proc/<PID>/cmdline`:

В файле /proc/<PID>/cmdline содержится командная строка,

используемая для запуска процесса <PID>. Этот файл состоит из

нулево-разделенных строк, содержащих параметры запуска 

процесса. Первый элемент в этом файле является полным путем к 

исполняемому файлу процесса.

`/proc/<PID>/exe`:

В файле /proc/<PID>/exe содержится символическая ссылка на 

исполняемый файл, который был запущен для процесса <PID>. Этот 

файл может быть использован для поиска бинарного файла, 

связанного с процессом. Если бинарный файл был перемещен или 

удален, ссылка на него все еще будет указывать на оригинальный 

файл, который был загружен в память при запуске процесса.

##	11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.

Старшая версия набора инструкций SSE которую поддерживает мой процессор: sse4_2

##	12. При открытии нового окна терминала и vagrant ssh создаётся новая сессия и выделяется pty.
Это можно подтвердить командой tty, которая упоминалась в лекции 3.2.

Однако:

vagrant@netology1:~$ ssh localhost 'tty'
not a tty

Почитайте, почему так происходит и как изменить поведение.

Ответ:

Это происходит потому, что по умолчанию ssh не выделяет tty, 

когда он запускает команду на удаленной машине. Вместо этого он

 использует протоколы ввода/вывода, такие как STDIN/STDOUT/
 
 STDERR, для связи с удаленным хостом.

Если вам нужно выделить tty в удаленной сессии SSH, вы можете

 использовать опцию -t при запуске SSH команды: ssh -t 
 
 user@host 'command'

 Это заставляет SSH выделять tty в удаленной сессии, что 
 
 позволяет использовать команды, которые требуют tty, такие как sudo.


##	13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.

Сначала создал новый скрин командой: screen -S test-1

Потом создал новое окно комбинацией клавиш ctrl+a c

В новом окне запустил htop

Перешел в предыдущее окно командой ctrl+a ",

Запустил  команду echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope для получения резрешения к процессу

Запустил reptyre 1984

##	14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell, который запущен без `sudo` под вашим пользователем. Для решения этой проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте, что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

Команда sudo echo string > /root/new_file не работает, потому 

что операция перенаправления вывода выполняется от имени 

пользователя, запустившего команду echo, который не имеет прав

 на запись в /root/new_file. Однако, команда echo string | sudo
 tee /root/new_file 
 
 работает, потому что операция записи в 
  
 файл выполняется с использованием привилегий пользователя, 
  
указанного в команде sudo, то есть с привилегиями 
  
пользователя root, который имеет права на запись в /root/new_file. 

Таким образом, команда tee позволяет обойти проблему доступа к 

файлу при использовании команды перенаправления вывода с sudo.

----
